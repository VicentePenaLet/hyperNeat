Class {
	#name : #NEAT,
	#superclass : #Object,
	#instVars : [
		'config',
		'populationSize',
		'population',
		'numberOfInputs',
		'numberOfOutputs',
		'logs',
		'fitness',
		'random',
		'log',
		'speciation',
		'numberOfGenerations',
		'shouldUseElitism',
		'speciationThreshold',
		'individualClass',
		'elitismN',
		'hNlog',
		'hNlogs',
		'logFileName',
		'populationId',
		'generations',
		'genNumber',
		'lastPopulation',
		'genealogy',
		'ActivationFunctionMutationOperationProb',
		'AddConnectionMutationOperationProb',
		'AddNodeMutationOperationProb',
		'ConnectionWeightMutationOperationProb',
		'CrossoverOperationProb',
		'generationRanked'
	],
	#category : #'HyperNeat-Core'
}

{ #category : #initialization }
NEAT >> activationFunctionMutationOperationProb: prob [
ActivationFunctionMutationOperationProb:= prob
]

{ #category : #initialization }
NEAT >> addConnectionMutationOperationProb: prob [
AddConnectionMutationOperationProb:= prob
]

{ #category : #initialization }
NEAT >> addNodeMutationOperationProb: prob [
AddNodeMutationOperationProb:= prob
]

{ #category : #initialization }
NEAT >> buildInitialPopulation [
	population := OrderedCollection new.
	populationId := 1.
	populationSize timesRepeat: [ 
		| i |
		i := individualClass new.
		i random: random.
		numberOfInputs timesRepeat: [ i addInputNode ].
		numberOfOutputs timesRepeat: [ i addOutputNode ].
		i id: populationId.
		i gen: genNumber.
		populationId := populationId +1.
		population add: i
		].
	self updateGenealogy.
	
]

{ #category : #initialization }
NEAT >> computeFitnesses [
	population do: [ :i | i computeFitness: fitness ].
	self rankPopulation.
]

{ #category : #initialization }
NEAT >> config [
	^ config
]

{ #category : #initialization }
NEAT >> connectionWeightMutationOperationProb: prob [
ConnectionWeightMutationOperationProb:= prob
]

{ #category : #'as yet unclassified' }
NEAT >> crossoverBetween: ind1 and: ind2 [
	^ ind1 fitness > ind2 fitness
		ifTrue: [ NECrossoverOperation new performOn: ind1 and: ind2 ]
		ifFalse: [ NECrossoverOperation new performOn: ind2 and: ind1 ]
]

{ #category : #initialization }
NEAT >> crossoverOperationProb: prob [
CrossoverOperationProb:= prob
]

{ #category : #'as yet unclassified' }
NEAT >> crossoverRate [
	| t |
	t := config detect: [ :assoc | assoc key isKindOf: NECrossoverOperation ] ifNone: [ ^ 0 ].
	^ t value
]

{ #category : #'as yet unclassified' }
NEAT >> currentGeneration [
	^ self logs size
	
]

{ #category : #initialization }
NEAT >> defaultConfig [
	self resetConfig.
	ActivationFunctionMutationOperationProb := 0.2.
	ConnectionWeightMutationOperationProb := 0.2.
	AddConnectionMutationOperationProb := 0.2.
	AddNodeMutationOperationProb := 0.2.
	CrossoverOperationProb := 0.2.
	self for: NEActivationFunctionMutationOperation prob: ActivationFunctionMutationOperationProb.
	self for: NEConnectionWeightMutationOperation prob: ConnectionWeightMutationOperationProb.
	self for: NEAddConnectionMutationOperation prob: AddConnectionMutationOperationProb.
	self for: NEAddNodeMutationOperation prob: AddNodeMutationOperationProb.
	self for: NECrossoverOperation prob: CrossoverOperationProb.
	logFileName:= 'logs/HyperNeat - logs.txt'.

]

{ #category : #initialization }
NEAT >> doHNLog [
	self assert: [ speciation notNil ].
	hNlog := HNLog new.
	hNlog fileName: logFileName.
	hNlog generation: logs size.
	hNlog worstFitness: (population collect: #fitness) min.
	hNlog bestFitness: (population collect: #fitness) max.
	hNlog averageFitness: ((population collect: #fitness) average asFloat round: 3).
	hNlog bestIndividual: (( self result)).
	hNlog bestN:((self getBestN: elitismN)).
	hNlog time: (DateAndTime now asString).
	hNlog population: (self population).
	population do: [ :ind| ind network: 0].
	"generations add: lastPopulation."
	hNlog writeToFile.
	"hNlog populationToFiles."
]

{ #category : #initialization }
NEAT >> doLog [
	self assert: [ speciation notNil ].
	log := NELog new.
	log generation: logs size.
	"log speciation: speciation."
	log minFitness: (population collect: #fitness) min.
	log maxFitness: (population collect: #fitness) max.
	log averageFitness: ((population collect: #fitness) average asFloat round: 3).
	log bestIndividual: (( self result)).
	log bestN:((self getBestN: elitismN)).
	logs add: log.
]

{ #category : #'as yet unclassified' }
NEAT >> doMutate: newInd [
	config
		do: [ :cAssoc | 
			(cAssoc key isKindOf: NEAbstractMutationOperation) ifTrue: [
				random next <= cAssoc value
					ifTrue: [ cAssoc key random: random; performOn: newInd ] ] ]
]

{ #category : #initialization }
NEAT >> doNotUseElitism [
	shouldUseElitism := false
]

{ #category : #initialization }
NEAT >> doSpeciation [
	speciation := NESpeciation new.
	speciation threshold: speciationThreshold.
	speciation process: population.
]

{ #category : #initialization }
NEAT >> doUseElitism [
	shouldUseElitism := true
]

{ #category : #accessing }
NEAT >> fitness [
	^ fitness
]

{ #category : #accessing }
NEAT >> fitness: anObject [
	fitness := anObject
]

{ #category : #initialization }
NEAT >> for: aClass [
	config do: [ :assoc | (assoc key isKindOf: aClass) ifTrue: [ ^ assoc value ] ].
	^ 0
]

{ #category : #initialization }
NEAT >> for: aClass prob: prob [
	config do: [ :assoc | (assoc key isKindOf: aClass) ifTrue: [ assoc value: prob. ^ self ] ].
	
	config add: aClass new -> prob
]

{ #category : #'as yet unclassified' }
NEAT >> genealogy [
^genealogy 
]

{ #category : #accessing }
NEAT >> generationRanked [
^generationRanked
]

{ #category : #initialization }
NEAT >> generations [
^generations

]

{ #category : #initialization }
NEAT >> generations: aPopulation [
generations := aPopulation

]

{ #category : #accessing }
NEAT >> getBestN: n [
	| winners popCopy|
	popCopy := population copy.
	winners := (1 to: n)collect: [ :unused| |winner winnerIndex|winner := popCopy first.
														winnerIndex := 1. 
														popCopy withIndexDo:  [ :i :index | winner fitness < i fitness ifTrue: [ winner := i. winnerIndex := index]].
	popCopy removeAt: winnerIndex.].
	^ winners
]

{ #category : #initialization }
NEAT >> individualClass: aClass [
	"Set the class to be used to create an individual.
	The default value is NEIndividual, but it could be a subclass of it."
	individualClass := aClass
]

{ #category : #initialization }
NEAT >> initialize [
	super initialize.
	self defaultConfig.

	"We have two inputs and one bias"
	numberOfInputs := 2.
	numberOfOutputs := 1.
	
	genNumber:= 1.
	populationSize := 150.
	random := Random seed: 42.
	elitismN := 10.
	logs := OrderedCollection new.
	hNlogs := OrderedCollection new.
	hNlog := HNLog new.
	hNlog fileName: logFileName.
	hNlog hyperParameters: (Array with: ActivationFunctionMutationOperationProb with: ConnectionWeightMutationOperationProb with: AddConnectionMutationOperationProb with: AddNodeMutationOperationProb with: CrossoverOperationProb).
	hNlog cleanFile.
	hNlog writeHeader.
	(FileSystem disk workingDirectory / 'logs' ) ensureCreateDirectory. 
	numberOfGenerations := 10.
	generations := OrderedCollection new.
	genealogy := HNGenealogy new.
	generationRanked := OrderedCollection new.
	self individualClass: NEIndividual.
	self speciationThreshold: 8.
	self doUseElitism.

]

{ #category : #'as yet unclassified' }
NEAT >> logFileName: filename [
logFileName:= filename.
self updateHyperParameters
	
]

{ #category : #initialization }
NEAT >> logs [
	^ logs
]

{ #category : #accessing }
NEAT >> numberOfGenerations [
	^ numberOfGenerations
]

{ #category : #accessing }
NEAT >> numberOfGenerations: anObject [
	numberOfGenerations := anObject
]

{ #category : #accessing }
NEAT >> numberOfInputs [
	^ numberOfInputs
]

{ #category : #accessing }
NEAT >> numberOfInputs: anObject [
	numberOfInputs := anObject
]

{ #category : #accessing }
NEAT >> numberOfOutputs [
	^ numberOfOutputs
]

{ #category : #accessing }
NEAT >> numberOfOutputs: anObject [
	numberOfOutputs := anObject
]

{ #category : #accessing }
NEAT >> population [
	^ population
]

{ #category : #accessing }
NEAT >> populationSize [
	^ populationSize
]

{ #category : #accessing }
NEAT >> populationSize: anObject [
	populationSize := anObject
]

{ #category : #accessing }
NEAT >> random [ 
^random
]

{ #category : #'as yet unclassified' }
NEAT >> rankPopulation [
|sorted rankedId|
sorted  := SortedCollection sortBlock: [:ind1 :ind2 | ind1 fitness >= ind2 fitness]. 
sorted addAll: self population.
rankedId := sorted collect: [ :ind| (ind id@ind fitness)].
generationRanked add: rankedId.
]

{ #category : #'as yet unclassified' }
NEAT >> releaseHistory [

	self logs allButLast do: #release
]

{ #category : #initialization }
NEAT >> resetConfig [
	config := OrderedCollection new
]

{ #category : #accessing }
NEAT >> result [
	| winner |
	winner := population first.
	population do: [ :i | winner fitness < i fitness ifTrue: [ winner := i ] ].
	^ winner
]

{ #category : #initialization }
NEAT >> run [
	self buildInitialPopulation.
	self doSpeciation.
	self computeFitnesses.
	self doLog.
	
	self runFor: numberOfGenerations.
	self doSpeciation.
	self doHNLog.
	self saveNeat

	

]

{ #category : #initialization }
NEAT >> runFor: nbGen [

	'Running the NEAT algorithm'
	displayProgressFrom: 1 to: nbGen
	during: [:bar |
		1 to: nbGen do: [:x | 
			bar value: x.
			self runOneGeneration. ] ].
]

{ #category : #'as yet unclassified' }
NEAT >> runOneGeneration [
	| newPopulation ind1 ind2 newInd numberOfIndividualToCreate |
	self doSpeciation.
	genNumber := genNumber+1.
	newPopulation := OrderedCollection new.
	numberOfIndividualToCreate := (shouldUseElitism and: [genNumber > 1 ]) 
												ifTrue: [ newPopulation addAll: self logs last bestN copy . populationSize - elitismN] 
												ifFalse: [ populationSize ].
	numberOfIndividualToCreate
		timesRepeat: [ 
			"The following lines use the crossover"
			random next <= self crossoverRate
				"using crossover"
				ifTrue: [
					"select firts individual"
					ind1 := self selectIndividual.
					"Select individuals for the same species as ind1"
					ind2 := self selectIndividual: ind1 species individuals.
					newInd := self crossoverBetween: ind1 and: ind2.
					newInd addParent: ind1; addParent: ind2.
					newInd crossOver: true.
					ind1 addChildren: newInd.
					ind2 addChildren: newInd ]
				"Without crossover"
				ifFalse: [
					| i |
					i := self selectIndividual.
					newInd := i copy.
					newInd addParent: i.
					newInd crossOver: false.
					i addChildren: newInd ].

			self doMutate: newInd.
			newInd id: populationId.
			newInd gen: genNumber.
			populationId:= populationId + 1.
			newPopulation add: newInd.
			newInd computeFitness: fitness ].
	lastPopulation := self population.
	population := newPopulation.
	"population do: [ :ind| ind gen: genNumber]."
	self updateGenealogy.
	self rankPopulation.
	self doHNLog.
	self doLog.
]

{ #category : #'as yet unclassified' }
NEAT >> saveNeat [
|str|
str := 'logs/neat.txt' asFileReference writeStream.
fitness := nil.
STON writer on: str;
    nextPut: self.
str close.

]

{ #category : #'as yet unclassified' }
NEAT >> selectIndividual [
	^ self selectIndividual: population
]

{ #category : #'as yet unclassified' }
NEAT >> selectIndividual: someIndividuals [
	| i k winner |
	k := 4.
	winner := someIndividuals atRandom: random.
	k timesRepeat: [ 
		"Maybe have a method NEIndividual>>sibblings"
		i := winner species individuals atRandom: random.
		winner fitness < i fitness ifTrue: [ winner := i ]
	].
	^ winner
]

{ #category : #initialization }
NEAT >> speciation [ 
^speciation
]

{ #category : #accessing }
NEAT >> speciationThreshold [
	^ speciationThreshold
]

{ #category : #accessing }
NEAT >> speciationThreshold: anInteger [
	"Per default, it is 3"
	speciationThreshold := anInteger
]

{ #category : #accessing }
NEAT >> tournamentSize: n [
elitismN := n.
]

{ #category : #initialization }
NEAT >> updateGenealogy [
	| thisGeneerationGenealogyInd |
	thisGeneerationGenealogyInd := population
		collect: [ :ind | 
			| id gen genInd parentsId childrenId parentGen indParents|
			id := ind id.
			gen := genNumber.
			parentsId := ind parents collect:[:parent| parent id].
			childrenId := ind parents collect:[:child|child id].
			parentGen := ind parents collect:[:parent| parent id].
			genInd := HNGenealogyIndividual new.
			genInd
				id: id;
				gen: gen;
				lastMutation: ind lastMutation;
				crossOver: ind crossOver;
				nNeurons: ind nodes size;
				nConnections: ind connections size.
			ind nodes do: [:node | genInd addToActivationFunction: node activation].
			indParents := parentsId flatCollect: [:parentId| (genealogy population at: (gen - 1)) select: [:each| each id = parentId]].
			indParents do: [ :parent|genInd addParent: parent. parent addChild: genInd].
			genInd.
			].
	genealogy add: thisGeneerationGenealogyInd
]

{ #category : #initialization }
NEAT >> updateHyperParameters [
hNlog fileName: logFileName.
hNlog hyperParameters: (Array with: ActivationFunctionMutationOperationProb with: ConnectionWeightMutationOperationProb with: AddConnectionMutationOperationProb with: AddNodeMutationOperationProb with: CrossoverOperationProb).
hNlog cleanFile.
hNlog writeHeader.
]

{ #category : #ui }
NEAT >> visualizeFitness [
	"Visualizing the max, min, and average fitness for each generation"
	| g d |
	g := RTGrapher new.
	
	"Min fitness"
	d := RTData new.
	d label: 'Minimum fitness'.
	d noDot; connectColor: Color red.
	d points: logs.
	d y: #minFitness.
	g add: d.
	
	"Max fitness"
	d := RTData new.
	d label: 'Maximum fitness'.
	d noDot; connectColor: Color blue.
	d points: logs.
	d y: #maxFitness.
	g add: d.
	
	"Average fitness"
	d := RTData new.
	d label: 'Average fitness'.
	d noDot; connectColor: Color green.
	d points: logs.
	d y: #averageFitness.
	g add: d.
	
	g axisX noDecimal; title: 'Generation'.
	g axisY title: 'Fitness'.
	g legend addText: 'Fitness evolution'.
	^ g
]

{ #category : #'as yet unclassified' }
NEAT >> visualizeGenerations [
	| b allIndividuals t |
	b := RTMondrian new.
	allIndividuals := OrderedCollection new.
	b
		nodes: (self logs allButFirst collect: #speciation)
		forEach: [ :spe | 
			b shape box size: #numberOfChildren.
			t := (spe population reverseSortedAs: #numberOfChildren)
				select: [ :ii | ii numberOfChildren >= 3 ].
			allIndividuals addAll: t.
			b nodes: t ].
	b layout verticalLine.
	b shape line color: Color blue trans.
	b edges
		objects: allIndividuals;
		connectToAll: #children.
	b normalizer
		objects: allIndividuals;
		normalizeColor: #fitness
			using:
			{Color red.
			Color gray}
			using: #squared.
	^ b
]

{ #category : #ui }
NEAT >> visualizeNumberOfSpecies [
	| g d |
	g := RTGrapher new.
	d := RTData new.
	d points: self logs.
	d y: #numberOfSpecies.
	g add: d.
	g axisX title: 'Generation'; noDecimal.
	g axisY title: '# species'.
	^ g
]

{ #category : #ui }
NEAT >> visualizeResultHistory [
	| b |
	b := RTMondrian new.
	b shape box size: #numberOfIndividuals.
	b interaction popupText: #averageFitness.
	b nodes: self result species withAllParentSpecies asSet.
	b edges connectToAll: #parentSpecies.
	b layout tree.
	b normalizer normalizeColor: #averageFitness.
	^ b
]

{ #category : #'as yet unclassified' }
NEAT >> visualizeSpeciesEvolution [
	"Species evolution"

	| allSpecies allSpeciations b |
	allSpecies := OrderedCollection new.
	allSpeciations := self logs collect: #speciation.
	b := RTMondrian new.
	b
		nodes: allSpeciations
		forEach: [ :sp | 
			allSpecies addAll: sp groups.
			b shape box size: #numberOfIndividuals.
			b nodes: sp groups ].
	b layout verticalLine alignCenter.
	b shape line
		color: Color blue trans;
		withShorterVerticalAttachPoint.
	b edges
		objects: allSpecies;
		connectToAll: #childrenSpecies.
	b normalizer
		objects: allSpecies;
		normalizeColor: #maxFitness.
	^ b
]
